import Foundation

// MARK: - Reply Suggestion Model

/**
 ReplySuggestion - Data Model for AI-Generated Reply

 LEARNING: Swift Structs and Data Modeling
 ==========================================
 In Swift, we model data using structs (value types) or classes (reference types).

 STRUCT vs CLASS:
 ================
 struct (VALUE type):
 - Copied when assigned/passed
 - No inheritance
 - Automatic memberwise init
 - Preferred in Swift for data models
 - Thread-safe by default

 class (REFERENCE type):
 - Shared reference when assigned/passed
 - Supports inheritance
 - Manual init required
 - Use when you need shared mutable state
 - Requires thread safety considerations

 WHY struct for ReplySuggestion?
 - It's pure data (no complex behavior)
 - We want copies, not shared references
 - Simpler and safer
 - Better performance

 PROTOCOLS this conforms to:
 ===========================
 1. Codable = Encodable + Decodable
    - Automatic JSON encoding/decoding
    - Works with JSONEncoder/JSONDecoder
    - No manual parsing needed!

 2. Identifiable
    - Required for SwiftUI ForEach
    - Provides stable identity for list items
    - Prevents unnecessary re-renders

 3. Equatable
    - Allows comparison with ==
    - Useful for diffing and testing
    - Auto-generated by Swift
 */
struct ReplySuggestion: Codable, Identifiable, Equatable {

    // MARK: - Properties

    /**
     LEARNING: Swift Property Types
     ===============================
     let: Immutable (constant) - value cannot change after initialization
     var: Mutable (variable) - value can change

     WHY use let when possible?
     - Safer: prevents accidental modification
     - Clearer: signals intent (this shouldn't change)
     - Optimized: compiler can make assumptions

     RULE OF THUMB: Use 'let' by default, only use 'var' when you need mutability
     */

    /// Unique identifier for this suggestion
    /// LEARNING: UUID (Universally Unique Identifier)
    /// - Guaranteed to be unique across time and space
    /// - 128-bit value, typically shown as: 123e4567-e89b-12d3-a456-426614174000
    /// - Perfect for identifying objects
    let id: UUID

    /// The actual reply text suggested by AI
    /// Example: "Thanks! I'll check that out ðŸ˜Š"
    let text: String

    /// The tone used to generate this reply
    /// Example: .friendly, .professional, .funny, .flirty
    let tone: Tone

    /// The platform this reply is optimized for
    /// Example: .whatsapp, .imessage, .outlook
    let platform: Platform

    /// When this suggestion was created
    /// LEARNING: Date in Swift
    /// - Represents a specific point in time
    /// - Can be formatted for display
    /// - Useful for sorting and filtering
    let createdAt: Date

    /// Confidence score from AI (0.0 to 1.0)
    /// Higher = AI is more confident this is a good reply
    /// LEARNING: Optional Type (?)
    /// - Can be nil (no value) or have a value
    /// - Prevents crashes from missing data
    /// - Use ? for optionals
    let confidence: Double?

    /// Whether the user has used this suggestion
    /// LEARNING: Mutable property (var)
    /// - Can be changed after creation
    /// - Useful for tracking state
    var isUsed: Bool

    // MARK: - Initialization

    /**
     LEARNING: Custom Initializer
     =============================
     Swift auto-generates a memberwise init, but we can provide our own
     for better defaults and convenience.

     INIT parameters:
     - Required parameters come first
     - Optional parameters have default values
     - This makes the API easier to use

     CONVENIENCE: Users don't need to provide id, createdAt, isUsed
     */
    init(
        id: UUID = UUID(),                    // Auto-generate unique ID
        text: String,                         // Required
        tone: Tone,                           // Required
        platform: Platform,                   // Required
        createdAt: Date = Date(),            // Default to now
        confidence: Double? = nil,            // Optional
        isUsed: Bool = false                  // Default to unused
    ) {
        self.id = id
        self.text = text
        self.tone = tone
        self.platform = platform
        self.createdAt = createdAt
        self.confidence = confidence
        self.isUsed = isUsed
    }

    // MARK: - Computed Properties

    /**
     LEARNING: Computed Properties
     ==============================
     Properties that don't store a value, they compute it on demand.

     SYNTAX:
     var propertyName: Type {
         // Compute and return value
     }

     WHEN to use computed properties vs stored properties:
     - Computed: Value derived from other properties
     - Stored: Value needs to be saved

     BENEFITS:
     - Keeps data consistent (always up-to-date)
     - Reduces stored data
     - Cleaner API
     */

    /// User-friendly time since creation (e.g., "2 minutes ago", "1 hour ago")
    var timeAgo: String {
        let now = Date()
        let interval = now.timeIntervalSince(createdAt)

        // LEARNING: Switch statement with ranges
        // Switch in Swift is powerful and exhaustive
        switch interval {
        case 0..<60:
            return "Just now"
        case 60..<3600:
            let minutes = Int(interval / 60)
            return "\(minutes) minute\(minutes == 1 ? "" : "s") ago"
        case 3600..<86400:
            let hours = Int(interval / 3600)
            return "\(hours) hour\(hours == 1 ? "" : "s") ago"
        default:
            let days = Int(interval / 86400)
            return "\(days) day\(days == 1 ? "" : "s") ago"
        }
    }

    /// Returns emoji representation of confidence score
    var confidenceEmoji: String {
        /**
         LEARNING: Guard Let vs If Let
         ===============================
         guard let: Early exit if condition fails
         - Good for validation at start of function
         - Unwrapped value available after guard

         if let: Continue if condition succeeds
         - Good for optional handling in middle of code
         - Unwrapped value only in if block

         HERE: Use guard to exit early if no confidence score
         */
        guard let score = confidence else { return "â“" }

        /**
         LEARNING: Switch with ranges on Double
         More readable than nested if/else
         Exhaustive checking (all cases covered)
         */
        switch score {
        case 0.9...1.0: return "ðŸ”¥" // Excellent
        case 0.7..<0.9: return "âœ…" // Good
        case 0.5..<0.7: return "ðŸ‘" // Okay
        case 0.0..<0.5: return "ðŸ¤”" // Low confidence
        default:        return "â“" // Unknown
        }
    }

    /// Character count of reply text
    /// Useful for showing length constraints
    var characterCount: Int {
        text.count
    }

    /// Word count of reply text
    var wordCount: Int {
        /**
         LEARNING: String Methods
         =========================
         Swift's String type is Unicode-correct and powerful
         - split(): Divides string by separator
         - filter(): Keeps only matching elements
         - isEmpty: Checks if string is empty
         */
        text.split(separator: " ")
            .filter { !$0.isEmpty }
            .count
    }

    // MARK: - Methods

    /**
     LEARNING: Methods (Functions on Types)
     =======================================
     Methods are functions that belong to a type.

     MUTATING keyword:
     - Required when method modifies self in a struct
     - Not needed in classes (reference types)
     - Signals to caller that value will change

     WHY mutating?
     - Structs are value types (immutable by default)
     - mutating allows changing self
     - Compiler enforces immutability without mutating
     */

    /// Mark this suggestion as used by the user
    mutating func markAsUsed() {
        isUsed = true
        Logger.debug("Marked suggestion as used: \(text.prefix(20))...")
    }

    /// Returns a copy with used status toggled
    /// LEARNING: Non-mutating method that returns modified copy
    /// Useful for SwiftUI's immutable data flow
    func toggledUsed() -> ReplySuggestion {
        var copy = self
        copy.isUsed.toggle()
        return copy
    }

    /**
     Format confidence as percentage string
     LEARNING: String Interpolation
     - \() embeds expressions in strings
     - Automatic type conversion
     */
    func confidencePercentage() -> String {
        guard let score = confidence else { return "N/A" }
        return String(format: "%.0f%%", score * 100)
    }

    // MARK: - Static Factory Methods

    /**
     LEARNING: Static Methods and Factory Pattern
     =============================================
     static: Method belongs to the type, not instances
     - Called on type: ReplySuggestion.preview()
     - Cannot access instance properties
     - Good for factory methods and utilities

     FACTORY PATTERN:
     - Named constructors for specific use cases
     - Clearer intent than init()
     - Can return nil if creation fails
     */

    /// Create a preview suggestion for SwiftUI previews
    static func preview(
        text: String = "Thanks! I'll check that out ðŸ˜Š",
        tone: Tone = .friendly,
        platform: Platform = .whatsapp
    ) -> ReplySuggestion {
        ReplySuggestion(
            text: text,
            tone: tone,
            platform: platform,
            confidence: 0.95
        )
    }

    /// Create multiple preview suggestions
    static func previews() -> [ReplySuggestion] {
        [
            ReplySuggestion(
                text: "Thanks! I'll check that out ðŸ˜Š",
                tone: .friendly,
                platform: .whatsapp,
                confidence: 0.95
            ),
            ReplySuggestion(
                text: "Appreciate it! Let me know if you need anything.",
                tone: .professional,
                platform: .outlook,
                confidence: 0.88
            ),
            ReplySuggestion(
                text: "Haha that's awesome! ðŸ˜‚",
                tone: .funny,
                platform: .instagram,
                confidence: 0.82
            ),
            ReplySuggestion(
                text: "You're the best! ðŸ’•",
                tone: .flirty,
                platform: .imessage,
                confidence: 0.76
            )
        ]
    }
}

// MARK: - Codable Keys

/**
 LEARNING: Custom Codable Implementation
 =======================================
 By default, Codable uses property names as JSON keys.
 CodingKeys lets us customize the mapping.

 WHEN to use CodingKeys:
 - JSON uses different naming (snake_case vs camelCase)
 - Need to rename properties
 - Want to exclude properties from encoding

 EXAMPLE JSON mapping:
 JSON: "created_at" â†” Swift: "createdAt"
 JSON: "is_used" â†” Swift: "isUsed"
 */
extension ReplySuggestion {
    enum CodingKeys: String, CodingKey {
        case id
        case text
        case tone
        case platform
        case createdAt = "created_at"        // Maps to snake_case
        case confidence
        case isUsed = "is_used"              // Maps to snake_case
    }
}

// MARK: - Extensions

/**
 LEARNING: Swift Extensions
 ==========================
 Add functionality to existing types without modifying original code.

 BENEFITS:
 - Organize code by functionality
 - Add protocol conformance
 - Extend types you don't own (String, Int, etc.)

 HERE: Add convenience methods for collection of suggestions
 */
extension Array where Element == ReplySuggestion {

    /// Sort suggestions by confidence score (highest first)
    func sortedByConfidence() -> [ReplySuggestion] {
        /**
         LEARNING: Sorted and Closures
         ==============================
         sorted(by:) takes a closure that compares two elements

         CLOSURE SYNTAX:
         { (param1, param2) in
             return comparison
         }

         SHORTHAND:
         { $0.property > $1.property }
         - $0: first parameter
         - $1: second parameter
         */
        sorted { (lhs, rhs) in
            let leftScore = lhs.confidence ?? 0.0
            let rightScore = rhs.confidence ?? 0.0
            return leftScore > rightScore
        }
    }

    /// Filter to only unused suggestions
    var unused: [ReplySuggestion] {
        /**
         LEARNING: Filter and Closures
         ==============================
         filter: Returns elements that match condition
         Closure receives each element and returns bool

         SHORTHAND: { !$0.isUsed }
         Same as: { suggestion in !suggestion.isUsed }
         */
        filter { !$0.isUsed }
    }

    /// Filter to only used suggestions
    var used: [ReplySuggestion] {
        filter { $0.isUsed }
    }

    /// Get suggestions for specific platform
    func forPlatform(_ platform: Platform) -> [ReplySuggestion] {
        filter { $0.platform == platform }
    }

    /// Get suggestions for specific tone
    func forTone(_ tone: Tone) -> [ReplySuggestion] {
        filter { $0.tone == tone }
    }
}

// MARK: - Documentation

/**
 KEY CONCEPTS LEARNED:
 =====================

 1. Structs vs Classes
    - Struct: Value type, copied, preferred for data
    - Class: Reference type, shared, for complex behavior

 2. Protocols
    - Codable: JSON encoding/decoding
    - Identifiable: Stable identity for SwiftUI
    - Equatable: Comparison with ==

 3. Properties
    - let: Immutable (constant)
    - var: Mutable (variable)
    - Computed: Derived from other properties

 4. Optionals
    - Type?: Can be nil or have value
    - guard let: Early exit if nil
    - if let: Unwrap if not nil

 5. Methods
    - mutating: Modifies struct
    - static: Belongs to type, not instance
    - Factory methods: Named constructors

 6. Collections
    - Array methods: filter, sorted, map
    - Closures: Anonymous functions
    - Shorthand: $0, $1 for parameters

 NEXT STEPS:
 ===========
 - Read Tone.swift for enum patterns
 - Read Platform.swift for more enums
 - Read APIClient.swift to see how this is decoded from JSON

 RESOURCES:
 ==========
 - Swift Language Guide: docs.swift.org/swift-book
 - Codable: developer.apple.com/documentation/swift/codable
 - Value vs Reference: developer.apple.com/swift/blog/?id=10
 */
